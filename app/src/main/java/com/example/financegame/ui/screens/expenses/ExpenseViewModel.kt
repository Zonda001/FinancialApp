package com.example.financegame.ui.screens.expenses

import android.app.Application
import android.content.Context
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.example.financegame.data.local.database.AppDatabase
import com.example.financegame.data.local.database.entities.*
import com.example.financegame.data.repository.ExpenseRepository
import com.example.financegame.data.repository.UserRepository
import com.example.financegame.util.AchievementTracker
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import java.util.*

class ExpenseViewModel(application: Application) : AndroidViewModel(application) {
    private val database = AppDatabase.getDatabase(application)
    private val expenseRepository = ExpenseRepository(database.expenseDao())
    private val userRepository = UserRepository(database.userDao())

    // SharedPreferences –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ª—ñ–º—ñ—Ç—É
    private val prefs = application.getSharedPreferences("ExpensePrefs", Context.MODE_PRIVATE)
    private val EXPENSE_LIMIT_KEY = "expense_limit"

    // üÜï –°–∏—Å—Ç–µ–º–∞ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –¥–æ—Å—è–≥–Ω–µ–Ω—å
    private val achievementTracker = AchievementTracker(database, viewModelScope, getApplication())

    private val _showAddDialog = MutableStateFlow(false)
    val showAddDialog: StateFlow<Boolean> = _showAddDialog

    // üÜï –õ—ñ–º—ñ—Ç –≤–∏—Ç—Ä–∞—Ç
    private val _expenseLimit = MutableStateFlow(prefs.getFloat(EXPENSE_LIMIT_KEY, 0f).toDouble())
    val expenseLimit: StateFlow<Double> = _expenseLimit

    val allExpenses: StateFlow<List<Expense>> = expenseRepository.getAllExpenses(1)
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )

    val currentMonthExpenses: StateFlow<Double> = flow {
        val calendar = Calendar.getInstance()
        calendar.set(Calendar.DAY_OF_MONTH, 1)
        calendar.set(Calendar.HOUR_OF_DAY, 0)
        calendar.set(Calendar.MINUTE, 0)
        val startOfMonth = calendar.timeInMillis

        expenseRepository.getTotalExpenses(1, startOfMonth, System.currentTimeMillis())
            .collect { emit(it ?: 0.0) }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = 0.0
    )

    val currentMonthIncome: StateFlow<Double> = flow {
        val calendar = Calendar.getInstance()
        calendar.set(Calendar.DAY_OF_MONTH, 1)
        calendar.set(Calendar.HOUR_OF_DAY, 0)
        calendar.set(Calendar.MINUTE, 0)
        val startOfMonth = calendar.timeInMillis

        expenseRepository.getTotalIncome(1, startOfMonth, System.currentTimeMillis())
            .collect { emit(it ?: 0.0) }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = 0.0
    )

    // üÜï –í—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—è –ª—ñ–º—ñ—Ç—É –≤–∏—Ç—Ä–∞—Ç
    fun setExpenseLimit(limit: Double) {
        viewModelScope.launch {
            _expenseLimit.value = limit
            prefs.edit().putFloat(EXPENSE_LIMIT_KEY, limit.toFloat()).apply()
        }
    }

    fun addExpense(
        amount: Double,
        category: String,
        type: ExpenseType,
        description: String = ""
    ) {
        viewModelScope.launch {
            val expense = Expense(
                userId = 1,
                amount = amount,
                category = category,
                type = type,
                description = description,
                date = System.currentTimeMillis()
            )
            expenseRepository.insertExpense(expense)

// –î–æ–¥–∞—î–º–æ –¥–æ—Å–≤—ñ–¥ –∑–∞ –¥–æ–¥–∞–≤–∞–Ω–Ω—è –≤–∏—Ç—Ä–∞—Ç–∏
            userRepository.addExperience(1, 10)

// üÜï –í—ñ–¥—Å—Ç–µ–∂—É—î–º–æ –¥–æ—Å—è–≥–Ω–µ–Ω–Ω—è
            achievementTracker.onExpenseAdded()

// ‚úÖ –û–ù–û–í–õ–Æ–Ñ–ú–û –ü–†–û–ì–†–ï–° –ö–í–ï–°–¢–Ü–í
            updateQuestProgress()

            _showAddDialog.value = false
        }
    }

    fun deleteExpense(expense: Expense) {
        viewModelScope.launch {
            expenseRepository.deleteExpense(expense)
        }
    }

    fun showAddExpenseDialog() {
        _showAddDialog.value = true
    }

    fun hideAddExpenseDialog() {
        _showAddDialog.value = false
    }
    private fun updateQuestProgress() {
        viewModelScope.launch {
            // –û–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å –≤—Å—ñ—Ö –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–≤–µ—Å—Ç—ñ–≤
            val activeQuests = database.questDao().getActiveQuests().first()

            activeQuests.forEach { quest ->
                when (quest.title) {
                    "–ü–µ—Ä—à–∏–π –∫—Ä–æ–∫" -> {
                        // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î —Ö–æ—á–∞ –± –æ–¥–Ω–∞ –≤–∏—Ç—Ä–∞—Ç–∞
                        val hasExpenses = database.expenseDao().getAllExpenses(1).first().isNotEmpty()
                        if (hasExpenses && quest.progress < 1f) {
                            database.questDao().updateQuestProgress(quest.id, 1f)
                        }
                    }
                    "–ü'—è—Ç—å —Ç—Ä–∞–Ω–∑–∞–∫—Ü—ñ–π" -> {
                        // –†–∞—Ö—É—î–º–æ –≤–∏—Ç—Ä–∞—Ç–∏ –∑–∞ —Å—å–æ–≥–æ–¥–Ω—ñ
                        val calendar = java.util.Calendar.getInstance()
                        calendar.set(java.util.Calendar.HOUR_OF_DAY, 0)
                        calendar.set(java.util.Calendar.MINUTE, 0)
                        val startOfDay = calendar.timeInMillis

                        val todayExpenses = database.expenseDao()
                            .getExpensesByDateRange(1, startOfDay, System.currentTimeMillis())
                            .first()
                            .filter { it.type == com.example.financegame.data.local.database.entities.ExpenseType.EXPENSE }
                            .size

                        val progress = (todayExpenses.toFloat() / 5f).coerceIn(0f, 1f)
                        database.questDao().updateQuestProgress(quest.id, progress)
                    }
                }
            }
        }
    }
}